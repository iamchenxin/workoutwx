{"version":3,"sources":["ts/tianwx.js"],"names":["crypto","require","PKCS7Encoder","decode","text","pad","length","slice","encode","blockSize","textLength","amountToPad","result","Buffer","fill","concat","WXBizMsgCrypt","token","encodingAESKey","id","Error","AESKey","key","iv","prototype","getSignature","timestamp","nonce","encrypt","shasum","createHash","arr","sort","update","join","digest","decrypt","decipher","createDecipheriv","setAutoPadding","up","end","final","deciphered","console","log","toString","content","readUInt32BE","message","randomString","pseudoRandomBytes","msg","msgLength","writeUInt32BE","bufMsg","encoded","cipher","createCipheriv","cipheredMsg","module","exports"],"mappings":"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","file":"tianwx.js","sourcesContent":["var crypto = require('crypto');\n\n/**\n * 提供基于PKCS7算法的加解密接口\n *\n */\nvar PKCS7Encoder = {};\n\n/**\n * 删除解密后明文的补位字符\n *\n * @param {String} text 解密后的明文\n */\nPKCS7Encoder.decode = function (text) {\n  var pad = text[text.length - 1];\n\n  if (pad < 1 || pad > 32) {\n    pad = 0;\n  }\n\n  return text.slice(0, text.length - pad);\n};\n\n/**\n * 对需要加密的明文进行填充补位\n *\n * @param {String} text 需要进行填充补位操作的明文\n */\nPKCS7Encoder.encode = function (text) {\n  var blockSize = 32;\n  var textLength = text.length;\n  //计算需要填充的位数\n  var amountToPad = blockSize - (textLength % blockSize);\n\n  var result = new Buffer(amountToPad);\n  result.fill(amountToPad);\n\n  return Buffer.concat([text, result]);\n};\n\n/**\n * 微信企业平台加解密信息构造函数\n *\n * @param {String} token          公众平台上，开发者设置的Token\n * @param {String} encodingAESKey 公众平台上，开发者设置的EncodingAESKey\n * @param {String} id         企业号的CorpId或者AppId\n */\nvar WXBizMsgCrypt = function (token, encodingAESKey, id) {\n  if (!token || !encodingAESKey || !id) {\n    throw new Error('please check arguments');\n  }\n  this.token = token;\n  this.id = id;\n  var AESKey = new Buffer(encodingAESKey + '=', 'base64');\n//  console.log(AESKey);\n  if (AESKey.length !== 32) {\n    throw new Error('encodingAESKey invalid');\n  }\n  this.key = AESKey;\n  this.iv = AESKey.slice(0, 16);\n\n};\n\n/**\n * 获取签名\n *\n * @param {String} timestamp    时间戳\n * @param {String} nonce        随机数\n * @param {String} encrypt      加密后的文本\n */\nWXBizMsgCrypt.prototype.getSignature = function(timestamp, nonce, encrypt) {\n  var shasum = crypto.createHash('sha1');\n  var arr = [this.token, timestamp, nonce, encrypt].sort();\n  shasum.update(arr.join(''));\n\n  return shasum.digest('hex');\n};\n\n/**\n * 对密文进行解密\n *\n * @param {String} text 待解密的密文\n */\nWXBizMsgCrypt.prototype.decrypt = function(text) {\n  // 创建解密对象，AES采用CBC模式，数据采用PKCS#7填充；IV初始向量大小为16字节，取AESKey前16字节\n  var decipher = crypto.createDecipheriv('aes-256-cbc', this.key, this.iv);\n  decipher.setAutoPadding(false);\n  const up = decipher.update(text, 'base64');\n  const end = decipher.final();\n  var deciphered = Buffer.concat([\n    up,\n    end,]);\n  console.log(deciphered.toString());\n  deciphered = PKCS7Encoder.decode(deciphered);\n  //console.log(deciphered.toString());\n  // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n  // 去除16位随机数\n  var content = deciphered.slice(16);\n  var length = content.slice(0, 4).readUInt32BE(0);\n\n  return {\n    message: content.slice(4, length + 4).toString(),\n    id: content.slice(length + 4).toString()\n  };\n};\n\n/**\n * 对明文进行加密\n *\n * @param {String} text 待加密的明文\n */\nWXBizMsgCrypt.prototype.encrypt = function (text) {\n  // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n  // 获取16B的随机字符串\n  var randomString = crypto.pseudoRandomBytes(16);\n\n  var msg = new Buffer(text);\n\n  // 获取4B的内容长度的网络字节序\n  var msgLength = new Buffer(4);\n  msgLength.writeUInt32BE(msg.length, 0);\n\n  var id = new Buffer(this.id);\n\n  var bufMsg = Buffer.concat([randomString, msgLength, msg, id]);\n\n  // 对明文进行补位操作\n  var encoded = PKCS7Encoder.encode(bufMsg);\n\n  // 创建加密对象，AES采用CBC模式，数据采用PKCS#7填充；IV初始向量大小为16字节，取AESKey前16字节\n  var cipher = crypto.createCipheriv('aes-256-cbc', this.key, this.iv);\n  cipher.setAutoPadding(false);\n\n  var cipheredMsg = Buffer.concat([cipher.update(encoded), cipher.final()]);\n\n  // 返回加密数据的base64编码\n  return cipheredMsg.toString('base64');\n};\n\nmodule.exports = WXBizMsgCrypt;\n"],"sourceRoot":"/home/iamchenxin/project/workout/wxts2/src"}