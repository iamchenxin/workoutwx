{"version":3,"sources":["utils/tmp.js"],"names":["crypto","require","PKCS7Encoder","decode","text","pad","length","slice","encode","blockSize","textLength","amountToPad","result","Buffer","fill","concat","WXBizMsgCrypt","token","encodingAESKey","id","Error","AESKey","key","iv","prototype","getSignature","timestamp","nonce","encrypt","shasum","createHash","arr","sort","update","join","digest","decrypt","decipher","createDecipheriv","setAutoPadding","deciphered","final","content","readUInt32BE","message","toString","randomString","pseudoRandomBytes","msg","msgLength","writeUInt32BE","bufMsg","encoded","cipher","createCipheriv","cipheredMsg","module","exports"],"mappings":"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","file":"tmp.js","sourcesContent":["\nconst crypto = require('crypto');\ndeclare class _crypto$Decipher extends stream$Duplex {\n  final(output_encoding: 'latin1' | 'ascii' | 'utf8'): string,\n  final(output_encoding: void): Buffer,\n  getAuthTag(): Buffer,\n  setAAD(buffer: Buffer): void,\n  setAuthTag(buffer: Buffer): void,\n  setAutoPadding(auto_padding?: boolean): crypto$Cipher,\n  update(\n    data: string,\n    input_encoding: 'latin1'| 'base64' | 'hex',\n    output_encoding: 'latin1' | 'ascii' | 'utf8',\n  ): string;\n  update(\n    data: string,\n    input_encoding: 'latin1'| 'base64' | 'hex',\n    output_encoding: void\n  ): Buffer;\n  update(\n    data: Buffer,\n    input_encoding: void,\n    output_encoding: 'latin1' | 'ascii' | 'utf8',\n  ): string;\n  update(\n    data: Buffer,\n    input_encoding: void,\n    output_encoding: void\n  ): Buffer;\n}\n/**\n * 提供基于PKCS7算法的加解密接口\n *\n */\nvar PKCS7Encoder = {};\n\n/**\n * 删除解密后明文的补位字符\n *\n * @param {String} text 解密后的明文\n */\nPKCS7Encoder.decode = function (text) {\n  var pad = text[text.length - 1];\n\n  if (pad < 1 || pad > 32) {\n    pad = 0;\n  }\n\n  return text.slice(0, text.length - pad);\n};\n\n/**\n * 对需要加密的明文进行填充补位\n *\n * @param {String} text 需要进行填充补位操作的明文\n */\nPKCS7Encoder.encode = function (text) {\n  var blockSize = 32;\n  var textLength = text.length;\n  //计算需要填充的位数\n  var amountToPad = blockSize - (textLength % blockSize);\n\n  var result = new Buffer(amountToPad);\n  result.fill(amountToPad);\n\n  return Buffer.concat([text, result]);\n};\n\n/**\n * 微信企业平台加解密信息构造函数\n *\n * @param {String} token          公众平台上，开发者设置的Token\n * @param {String} encodingAESKey 公众平台上，开发者设置的EncodingAESKey\n * @param {String} id         企业号的CorpId或者AppId\n */\nvar WXBizMsgCrypt = function (token, encodingAESKey, id) {\n  if (!token || !encodingAESKey || !id) {\n    throw new Error('please check arguments');\n  }\n  this.token = token;\n  this.id = id;\n  var AESKey = new Buffer(encodingAESKey + '=', 'base64');\n  if (AESKey.length !== 32) {\n    throw new Error('encodingAESKey invalid');\n  }\n  this.key = AESKey;\n  this.iv = AESKey.slice(0, 16);\n};\n\n/**\n * 获取签名\n *\n * @param {String} timestamp    时间戳\n * @param {String} nonce        随机数\n * @param {String} encrypt      加密后的文本\n */\nWXBizMsgCrypt.prototype.getSignature = function(timestamp, nonce, encrypt) {\n  var shasum = crypto.createHash('sha1');\n  var arr = [this.token, timestamp, nonce, encrypt].sort();\n  shasum.update(arr.join(''));\n\n  return shasum.digest('hex');\n};\n\n/**\n * 对密文进行解密\n *\n * @param {String} text 待解密的密文\n */\nWXBizMsgCrypt.prototype.decrypt = function(text) {\n  // 创建解密对象，AES采用CBC模式，数据采用PKCS#7填充；IV初始向量大小为16字节，取AESKey前16字节\n  var decipher = crypto.createDecipheriv('aes-256-cbc', this.key, this.iv);\n  decipher.setAutoPadding(false);\n  var deciphered = Buffer.concat([decipher.update(text, 'base64'), decipher.final()]);\n\n  deciphered = PKCS7Encoder.decode(deciphered);\n  // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n  // 去除16位随机数\n  var content = deciphered.slice(16);\n  var length = content.slice(0, 4).readUInt32BE(0);\n\n  return {\n    message: content.slice(4, length + 4).toString(),\n    id: content.slice(length + 4).toString()\n  };\n};\n\n/**\n * 对明文进行加密\n *\n * @param {String} text 待加密的明文\n */\nWXBizMsgCrypt.prototype.encrypt = function (text) {\n  // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n  // 获取16B的随机字符串\n  var randomString = crypto.pseudoRandomBytes(16);\n\n  var msg = new Buffer(text);\n\n  // 获取4B的内容长度的网络字节序\n  var msgLength = new Buffer(4);\n  msgLength.writeUInt32BE(msg.length, 0);\n\n  var id = new Buffer(this.id);\n\n  var bufMsg = Buffer.concat([randomString, msgLength, msg, id]);\n\n  // 对明文进行补位操作\n  var encoded = PKCS7Encoder.encode(bufMsg);\n\n  // 创建加密对象，AES采用CBC模式，数据采用PKCS#7填充；IV初始向量大小为16字节，取AESKey前16字节\n  var cipher = crypto.createCipheriv('aes-256-cbc', this.key, this.iv);\n  cipher.setAutoPadding(false);\n\n  var cipheredMsg = Buffer.concat([cipher.update(encoded), cipher.final()]);\n\n  // 返回加密数据的base64编码\n  return cipheredMsg.toString('base64');\n};\n\nmodule.exports = WXBizMsgCrypt;\n"],"sourceRoot":"/home/iamchenxin/project/workout/wxts2/src"}