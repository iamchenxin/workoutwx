{"version":3,"sources":["wxlib/wxcrypto.js"],"names":["crypto","require","pro","mustNot","mustBe","blockSize","PKCS7Encoder","encode","buff","amountToPad","length","pad","Buffer","alloc","fill","concat","decode","slice","Prpcrypt","constructor","token","encodingAESKey","corpId","AESKey","from","key","iv","decrypt","cipherStr","decipher","createDecipheriv","setAutoPadding","plainBuf","update","final","wx_buf","content","msgLength","readInt32BE","message","toString","id","encrypt","plainMsg","randomStr","pseudoRandomBytes","msgBuf","msgLengthBuf","writeUInt32BE","corpIDBuf","dataBuf","pkcs7buf","cipher","createCipheriv","cipheredBuf","getSignature","timestamp","nonce","cipheredTxt","shasum","createHash","arr","sort","join","digest"],"mappings":"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","file":"wxcrypto.js","sourcesContent":["// @flow\n\nconst crypto = require('crypto');\nconst pro = require('flow-dynamic').pro;\nconst {mustNot, mustBe} = pro;\ndeclare class _crypto$Decipher extends stream$Duplex {\n  final(output_encoding: 'latin1' | 'ascii' | 'utf8'): string,\n  final(output_encoding: void): Buffer,\n  getAuthTag(): Buffer,\n  setAAD(buffer: Buffer): void,\n  setAuthTag(buffer: Buffer): void,\n  setAutoPadding(auto_padding?: boolean): crypto$Cipher,\n  update(\n    data: string,\n    input_encoding: 'latin1'| 'base64' | 'hex',\n    output_encoding: 'latin1' | 'ascii' | 'utf8',\n  ): string;\n  update(\n    data: string,\n    input_encoding: 'latin1'| 'base64' | 'hex',\n    output_encoding: void\n  ): Buffer;\n  update(\n    data: Buffer,\n    input_encoding: void,\n    output_encoding: 'latin1' | 'ascii' | 'utf8',\n  ): string;\n  update(\n    data: Buffer,\n    input_encoding: void,\n    output_encoding: void\n  ): Buffer;\n}\n\ntype WXParams = {\n  msg_signature: string,\n  timestamp: string, // should be uint string\n  nonce: string, // should be uint string\n  echostr: string,\n};\n/**\n * 提供基于PKCS7算法的加解密接口\n *\n */\nconst blockSize:number = 32;\nconst PKCS7Encoder = {\n  /**\n   * 填补加密的 Buffer 对齐 32位 // blockSize\n   *\n   * @param {Buffer} Buffer 需要进行填充补位操作的Buffer\n   */\n  encode(buff: Buffer): Buffer {\n    let amountToPad = blockSize - (buff.length % blockSize);\n    if ( amountToPad == 0 ) {\n      amountToPad = blockSize;\n    }\n\n    const pad = Buffer.alloc(amountToPad);\n    pad.fill(amountToPad);\n    //const pad = mustNot(undefined, _pad, 'PKCS7Encoder encode failed!');\n    return Buffer.concat([buff, pad]);\n  },\n\n  /**\n   * 删除解密后Buffer的补位\n   *\n   * @param {Buffer} Buffer 解密后的Buffer\n  */\n  decode(buff: Buffer): Buffer {\n    let pad = buff[buff.length -1];\n    if (pad < 1 || pad > 32) {\n        pad = 0;\n    }\n    return buff.slice(0, buff.length - pad);\n  }\n}\n\n/**\n * Prpcrypt class\n *\n * 提供接收和推送给公众平台消息的加解密接口.\n */\nclass Prpcrypt {\n  token: string;\n  corpId: string;\n  key: Buffer;\n  iv: Buffer;\n  constructor(token: string, encodingAESKey: string, corpId: string) {\n    this.token = token;\n    this.corpId = corpId;\n    const AESKey = Buffer.from(encodingAESKey + '=', 'base64');\n    mustBe(32, AESKey.length, 'encodingAESKey invalid');\n    this.key = AESKey;\n    this.iv = AESKey.slice(0, 16);\n  }\n\n  decrypt(cipherStr: string) {\n    // 创建解密对象，AES采用CBC模式，数据采用PKCS#7填充；\n    // IV初始向量大小为16字节，取AESKey前16字节\n    const decipher: _crypto$Decipher =\n      (crypto.createDecipheriv('aes-256-cbc', this.key, this.iv): any);\n    decipher.setAutoPadding(false);\n    const plainBuf = Buffer.concat([\n      decipher.update(cipherStr, 'base64'),\n      decipher.final(),\n    ]);\n    const wx_buf = PKCS7Encoder.decode(plainBuf);\n    // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n    // 去除16位随机数\n    const content = wx_buf.slice(20);\n    const msgLength = wx_buf.slice(16, 20).readInt32BE(0);\n    return {\n      message: content.slice(0, msgLength).toString(),\n      id: content.slice(msgLength).toString(),\n    };\n  }\n\n  encrypt(plainMsg: string): string {\n    // 算法：AES_Encrypt[random(16B) + msg_len(4B) + msg + $CorpID]\n    // 获取16B的随机字符串\n    const randomStr = crypto.pseudoRandomBytes(16);\n\n    const msgBuf = Buffer.from(plainMsg, 'utf8');\n\n    const msgLengthBuf = Buffer.alloc(4); // msg_len(4B)\n    msgLengthBuf.writeUInt32BE(msgBuf.length, 0);\n\n    const corpIDBuf = Buffer.from(this.corpId, 'utf8');\n    const dataBuf = Buffer.concat([\n      randomStr, msgLengthBuf, msgBuf, corpIDBuf\n    ]);\n\n    // 对buf进行补位操作\n    const pkcs7buf = PKCS7Encoder.encode(dataBuf);\n\n    const cipher = crypto.createCipheriv('aes-256-cbc', this.key, this.iv);\n    cipher.setAutoPadding(false);\n\n    const cipheredBuf = Buffer.concat([\n      cipher.update(pkcs7buf), cipher.final(),\n    ]);\n\n    return cipheredBuf.toString('base64');\n  }\n\n  // 微信的签名是 'hex'\n  getSignature( timestamp: string, nonce: string, cipheredTxt: string): string {\n    var shasum = crypto.createHash('sha1');\n    var arr = [this.token, timestamp, nonce, cipheredTxt].sort();\n    shasum.update(arr.join(''));\n    return shasum.digest('hex');\n  };\n}\nexport type {\n  WXParams\n}\nexport {\n  Prpcrypt\n};\n"],"sourceRoot":"/home/iamchenxin/project/workout/wxts2/src"}